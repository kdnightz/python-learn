# numpy

## transpose()

``` python
x = np.arange(12).reshape((2,2,3))

print(x)

[[[ 0  1  2]

  [ 3  4  5]]

 [[ 6  7  8]

  [ 9 10 11]]]



x = np.transpose(x,(1,0,2))  //transpose()函数的第二个参数就是改变索引值的地方

print(x)

[[[ 0  1  2]

  [ 6  7  8]]

 [[ 3  4  5]

  [ 9 10 11]]]

通过transpose()函数改变了x的索引值为（1，0，2），对应（y，x，z）

索引改变后原本y的值和x的值对换了。

有上面代码的数字7为例，原本的7的位置索引为（1,0,1），通过transpose（x，（1，0，2））索引改变为（0，1，1）
```

# dropout

``` python
# 展平过程中，用于随机失活，防止过拟合
nn.Dropout(p=0.5)
```

# 基础函数

``` python
vars = {} 只能是定义空字典，
而如果像定义空集合，只能用 set() 方法
vars = set()
# 无法获取集合中的单个元素，但是可以添加和删除
```



# lambda

```python
lambda 参数列表 : 表达式
#lambda的参数列表可有可无，函数的参数在lambda表达式中完全适用
#lambda表达式能接收任何数量的参数但只能返回一个表达式的值

#形象理解 lambda 接收参数：返回

x作为一个列表，列表中存放字典，并且需要对其排序时，key这个参数就起到作用。key形象于字典kv中的k。第一个a是要升或者降的数据，在这里就是字典，冒号后是对字典中那个k进行排序
x.sort(key=lambda a:a['name'])
```



# map

```python
#map(func, lst) 将传入的函数变量func作用到lst变量的每个元素中，并将结果组成新的迭代器返回
```

# reduce

```python
# reduce(func, lst) 其中func必须要两个参数，每次func计算的结果继续和序列的下一个元素做累积计算。

```

# filter

```python
filter(func, lst) 过滤序列，过滤掉不符合条件的元素，返回一个filter对象，如果要转换为列表，可以用 list（）转换。
```



# 字典生成式

​	理解列表生成式 list = [ x**2 for x in x_test if x%2 == 0]

​	再到字典生成式： dic = {x*x for x in x_test if x&2 != 0}



# *args 和 **kwargs

## *args

- *args 用来将参数打包成tuple给函数体调用

## **kwagrs

- **kwargs 打包关键字参数成dict给函数体调用



参数arg、*args、**kwargs三个参数的位置必须是一定的。必须是(arg,*args,**kwargs)这个顺序，否则程序会报错。

​	



# 生成器 迭代器



# numpy

### 1. 取不连续的多行

`t[[2,8,10]]`

### 2.取连续的多行

`t[2:]`

### 3.取列
```python
# :是所有，   逗号 前是行，后是列
前言：
t[1,:] # 既是 逗号前取行.后取行，这里表示每一列都要
t[2:,:] # ？从第二行开始取，列都要
t[[2,3,10],:] # 取不连续的行，列都要


t[:,2:] #行都要，列从第二列开始取后面都要
t[:,[0,2]] # 行都要，列取不连续的，取0,2列

t[2:5,1:4] # 取的是行列交叉点的位置，比如该只取2-4行里，1-3列的数据

t[[0,2],[0,1]] # 取不相邻的点，此时0对0,2对1，所以取0行0列的值和2行1列的值
```

